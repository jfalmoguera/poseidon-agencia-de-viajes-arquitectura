import * as i0 from '@angular/core';
import { Injectable, Directive, ViewContainerRef, Input, TemplateRef, NgModule, ComponentFactoryResolver, Injector, ApplicationRef, Component } from '@angular/core';
import { BehaviorSubject } from 'rxjs';
import { filter, map } from 'rxjs/operators';

class TeleportService {
    constructor() {
        this.outlets = new BehaviorSubject('');
        this.asObservable = this.outlets.asObservable();
        this.ports = new Map();
    }
    outlet$(name) {
        return this.asObservable.pipe(filter(current => current === name), map(name => this.ports.get(name)));
    }
    newOutlet(name) {
        this.outlets.next(name);
    }
}
TeleportService.ɵprov = i0.ɵɵdefineInjectable({ factory: function TeleportService_Factory() { return new TeleportService(); }, token: TeleportService, providedIn: "root" });
TeleportService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];

class TeleportOutletDirective {
    constructor(vcr, service) {
        this.vcr = vcr;
        this.service = service;
    }
    ngOnInit() {
        this.service.ports.set(this.teleportOutlet, this.vcr);
        this.service.newOutlet(this.teleportOutlet);
    }
    ngOnDestroy() {
        this.service.ports.delete(this.teleportOutlet);
    }
}
TeleportOutletDirective.decorators = [
    { type: Directive, args: [{
                selector: '[teleportOutlet]',
            },] }
];
TeleportOutletDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TeleportService }
];
TeleportOutletDirective.propDecorators = {
    teleportOutlet: [{ type: Input }]
};

class TeleportDirective {
    constructor(tpl, service) {
        this.tpl = tpl;
        this.service = service;
    }
    ngOnInit() {
        this.subscription = this.service.outlet$(this.teleportTo).subscribe((outlet) => {
            if (outlet) {
                this.viewRef = outlet.createEmbeddedView(this.tpl);
            }
        });
    }
    ngOnDestroy() {
        var _a, _b;
        (_a = this.subscription) === null || _a === void 0 ? void 0 : _a.unsubscribe();
        (_b = this.viewRef) === null || _b === void 0 ? void 0 : _b.destroy();
    }
}
TeleportDirective.decorators = [
    { type: Directive, args: [{
                selector: '[teleportTo]',
            },] }
];
TeleportDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: TeleportService }
];
TeleportDirective.propDecorators = {
    teleportTo: [{ type: Input }]
};
class TeleportModule {
}
TeleportModule.decorators = [
    { type: NgModule, args: [{
                declarations: [TeleportDirective, TeleportOutletDirective],
                exports: [TeleportDirective, TeleportOutletDirective],
            },] }
];

function isTemplateRef(value) {
    return value instanceof TemplateRef;
}
function isComponent(value) {
    return typeof value === 'function';
}
function isString(value) {
    return typeof value === 'string';
}

class TplRef {
    constructor(args) {
        this.args = args;
        this.wrapper = null;
        if (this.args.vcr) {
            this.viewRef = this.args.vcr.createEmbeddedView(this.args.tpl, this.args.context || {});
            this.viewRef.detectChanges();
        }
        else {
            this.viewRef = this.args.tpl.createEmbeddedView(this.args.context || {});
            this.viewRef.detectChanges();
            this.args.appRef.attachView(this.viewRef);
        }
    }
    detectChanges() {
        this.viewRef.detectChanges();
    }
    getElement() {
        const rootNodes = this.viewRef.rootNodes;
        if (rootNodes.length === 1 && rootNodes[0] === Node.ELEMENT_NODE) {
            this.element = rootNodes[0];
        }
        else {
            this.element = document.createElement('div');
            this.element.append(...rootNodes);
        }
        return this.element;
    }
    destroy() {
        var _a;
        if (this.viewRef.rootNodes[0] !== 1) {
            (_a = this.element) === null || _a === void 0 ? void 0 : _a.parentNode.removeChild(this.element);
            this.element = null;
        }
        if (!this.args.vcr) {
            this.args.appRef.detachView(this.viewRef);
        }
        this.viewRef.destroy();
        this.viewRef = null;
    }
}

class StringRef {
    constructor(value) {
        this.value = value;
    }
    getElement() {
        return this.value;
    }
    detectChanges() { }
    destroy() { }
}

class CompRef {
    constructor(args) {
        this.args = args;
        const factory = this.args.resolver.resolveComponentFactory(this.args.component);
        if (this.args.vcr) {
            this.compRef = this.args.vcr.createComponent(factory, this.args.vcr.length, args.injector || this.args.vcr.injector);
        }
        else {
            this.compRef = factory.create(this.args.injector);
            this.args.appRef.attachView(this.compRef.hostView);
        }
    }
    get ref() {
        return this.compRef;
    }
    setInput(input, value) {
        this.compRef.instance[input] = value;
        return this;
    }
    setInputs(inputs) {
        Object.keys(inputs).forEach((input) => {
            this.compRef.instance[input] = inputs[input];
        });
        return this;
    }
    detectChanges() {
        this.compRef.hostView.detectChanges();
        return this;
    }
    appendTo(container) {
        container.appendChild(this.getElement());
        return this;
    }
    removeFrom(container) {
        container.removeChild(this.getElement());
        return this;
    }
    getRawContent() {
        return this.getElement().outerHTML;
    }
    getElement() {
        return this.compRef.location.nativeElement;
    }
    destroy() {
        this.compRef.destroy();
        !this.args.vcr && this.args.appRef.detachView(this.compRef.hostView);
        this.compRef = null;
    }
}

class ViewService {
    constructor(resolver, injector, appRef) {
        this.resolver = resolver;
        this.injector = injector;
        this.appRef = appRef;
    }
    createComponent(component, options = {}) {
        return new CompRef({
            component,
            vcr: options.vcr,
            injector: options.injector || this.injector,
            appRef: this.appRef,
            resolver: this.resolver,
        });
    }
    createTemplate(tpl, options = {}) {
        return new TplRef({
            vcr: options.vcr,
            appRef: this.appRef,
            tpl,
            context: options.context,
        });
    }
    createView(content, viewOptions = {}) {
        if (isTemplateRef(content)) {
            return this.createTemplate(content, viewOptions);
        }
        else if (isComponent(content)) {
            return this.createComponent(content, viewOptions);
        }
        else if (isString(content)) {
            return new StringRef(content);
        }
        else {
            throw 'Type of content is not supported';
        }
    }
}
ViewService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ViewService_Factory() { return new ViewService(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i0.ApplicationRef)); }, token: ViewService, providedIn: "root" });
ViewService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
ViewService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: Injector },
    { type: ApplicationRef }
];

class DynamicViewComponent {
}
DynamicViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'dynamic-view',
                template: ` <div [innerHTML]="content"></div> `
            },] }
];
DynamicViewComponent.propDecorators = {
    content: [{ type: Input }]
};

class DynamicViewDirective {
    constructor(defaultTpl, vcr, viewService) {
        this.defaultTpl = defaultTpl;
        this.vcr = vcr;
        this.viewService = viewService;
    }
    set view(content) {
        this._view = content;
        this.resolveContentType();
    }
    get view() {
        return this._view;
    }
    ngOnInit() {
        this.resolveContentType();
    }
    resolveContentType() {
        var _a;
        (_a = this.viewRef) === null || _a === void 0 ? void 0 : _a.destroy();
        if (isString(this.view)) {
            this.viewRef = this.viewService.createComponent(DynamicViewComponent, {
                vcr: this.vcr,
                injector: this.injector,
            });
            this.viewRef.setInput('content', this.view).detectChanges();
        }
        else {
            this.viewRef = this.viewService.createView(this.view || this.defaultTpl, {
                vcr: this.vcr,
                injector: this.injector,
                context: this.context,
            });
        }
    }
    ngOnDestroy() {
        var _a;
        (_a = this.viewRef) === null || _a === void 0 ? void 0 : _a.destroy();
    }
}
DynamicViewDirective.decorators = [
    { type: Directive, args: [{
                selector: '[dynamicView]',
            },] }
];
DynamicViewDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: ViewService }
];
DynamicViewDirective.propDecorators = {
    view: [{ type: Input, args: ['dynamicView',] }],
    injector: [{ type: Input, args: ['dynamicViewInjector',] }],
    context: [{ type: Input, args: ['dynamicViewContext',] }]
};
class DynamicViewModule {
}
DynamicViewModule.decorators = [
    { type: NgModule, args: [{
                declarations: [DynamicViewDirective, DynamicViewComponent],
                exports: [DynamicViewDirective],
            },] }
];

/*
 * Public API Surface of overview
 */

/**
 * Generated bundle index. Do not edit.
 */

export { CompRef, DynamicViewDirective, DynamicViewModule, StringRef, TeleportDirective, TeleportModule, TeleportOutletDirective, TplRef, ViewService, isComponent, isString, isTemplateRef, TeleportService as ɵa, DynamicViewComponent as ɵb };
//# sourceMappingURL=ngneat-overview.js.map
